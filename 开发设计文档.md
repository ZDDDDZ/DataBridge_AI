# 管道信息系统 - 开发与设计文档

## 目录
1. [系统概述](#系统概述)
2. [数据库设计](#数据库设计)
3. [后端开发](#后端开发)
4. [前端开发](#前端开发)
5. [系统集成](#系统集成)

## 系统概述

本系统是一个管道信息查询分析平台，通过大语言模型技术实现自然语言查询功能。用户可以通过输入自然语言问题，系统会识别查询意图并转换为SQL查询，从数据库检索相关管道信息并以可视化方式展示结果。

## 数据库设计

### MySQL数据库创建

```sql
CREATE DATABASE IF NOT EXISTS pipeline_management;
USE pipeline_management;

CREATE TABLE IF NOT EXISTS pipeline_info (
    id INT AUTO_INCREMENT PRIMARY KEY,
    province VARCHAR(50) NOT NULL COMMENT '省',
    city VARCHAR(50) NOT NULL COMMENT '市',
    street VARCHAR(100) COMMENT '街道',
    road VARCHAR(100) COMMENT '路',
    location VARCHAR(255) COMMENT '具体位置',
    disaster_type VARCHAR(50) COMMENT '灾害类型',
    geological_feature VARCHAR(100) COMMENT '地质特性',
    pipeline_type VARCHAR(50) NOT NULL COMMENT '管线类型',
    build_year INT COMMENT '建成年份',
    laying_method VARCHAR(50) COMMENT '敷设方式',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='管道信息表';
```

### 模拟数据生成脚本

```python
import mysql.connector
import random
from datetime import datetime

# 数据库连接配置
db_config = {
    "host": "localhost",
    "user": "root",
    "password": "your_password",
    "database": "pipeline_management"
}

# 模拟数据
provinces = ["北京", "上海", "广东", "浙江", "江苏", "四川", "湖北", "山东"]
cities = {
    "北京": ["朝阳区", "海淀区", "丰台区", "西城区", "东城区"],
    "上海": ["浦东新区", "黄浦区", "静安区", "徐汇区", "长宁区"],
    "广东": ["广州", "深圳", "珠海", "佛山", "东莞"],
    "浙江": ["杭州", "宁波", "温州", "嘉兴", "湖州"],
    "江苏": ["南京", "苏州", "无锡", "常州", "镇江"],
    "四川": ["成都", "绵阳", "德阳", "自贡", "宜宾"],
    "湖北": ["武汉", "黄石", "襄阳", "宜昌", "十堰"],
    "山东": ["济南", "青岛", "烟台", "威海", "潍坊"]
}
streets = ["中心街", "文化路", "新华街", "解放路", "建设大道", "和平路", "友谊大街", "长江路", "黄河路"]
roads = ["一号路", "二号路", "三号路", "四号路", "主干道", "辅路", "环线", "联络道"]
disaster_types = ["地震", "洪水", "滑坡", "塌陷", "冻土融化", "台风", "暴雨", "无"]
geological_features = ["砂质土", "粘土", "岩石", "软土", "硬土", "沙土", "碎石", "黏土夹砂", "卵石层"]
pipeline_types = ["供水管道", "排水管道", "燃气管道", "热力管道", "电力管线", "通信管线", "石油管道", "化工管道"]
laying_methods = ["直埋", "架空", "沟槽", "盾构", "顶管", "定向钻", "悬吊", "综合管廊"]

def generate_mock_data(count=1000):
    try:
        conn = mysql.connector.connect(**db_config)
        cursor = conn.cursor()
        
        for _ in range(count):
            province = random.choice(provinces)
            city = random.choice(cities[province])
            street = random.choice(streets)
            road = random.choice(roads)
            location = f"{street}与{road}交叉口附近{random.randint(10, 500)}米"
            disaster_type = random.choice(disaster_types)
            geological_feature = random.choice(geological_features)
            pipeline_type = random.choice(pipeline_types)
            build_year = random.randint(1980, 2023)
            laying_method = random.choice(laying_methods)
            
            query = """
            INSERT INTO pipeline_info 
            (province, city, street, road, location, disaster_type, geological_feature, 
            pipeline_type, build_year, laying_method)
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
            """
            values = (province, city, street, road, location, disaster_type, 
                     geological_feature, pipeline_type, build_year, laying_method)
            
            cursor.execute(query, values)
        
        conn.commit()
        print(f"成功插入{count}条模拟数据")
    
    except Exception as e:
        print(f"数据插入错误: {e}")
    
    finally:
        if conn.is_connected():
            cursor.close()
            conn.close()

if __name__ == "__main__":
    generate_mock_data(1000)
```

## 后端开发

### 项目结构

```
pipeline_backend/
├── app/
│   ├── __init__.py
│   ├── config.py
│   ├── models/
│   │   └── __init__.py
│   ├── api/
│   │   ├── __init__.py
│   │   └── routes.py
│   ├── services/
│   │   ├── __init__.py
│   │   ├── db_service.py
│   │   └── llm_service.py
│   └── utils/
│       ├── __init__.py
│       └── sql_generator.py
├── requirements.txt
└── main.py
```

### 依赖安装

创建`requirements.txt`文件：

```
fastapi==0.104.1
uvicorn==0.23.2
langchain==0.0.335
langchain-community==0.0.13
pymysql==1.1.0
python-dotenv==1.0.0
requests==2.31.0
pydantic==2.4.2
```

### 配置文件 (config.py)

```python
import os
from dotenv import load_dotenv

load_dotenv()

class Config:
    # 数据库配置
    DB_HOST = os.getenv("DB_HOST", "localhost")
    DB_PORT = int(os.getenv("DB_PORT", 3306))
    DB_USER = os.getenv("DB_USER", "root")
    DB_PASSWORD = os.getenv("DB_PASSWORD", "your_password")
    DB_NAME = os.getenv("DB_NAME", "pipeline_management")
    
    # 阿里云百炼大模型配置
    ALIBABA_MODEL_API_KEY = os.getenv("ALIBABA_MODEL_API_KEY", "")
    ALIBABA_MODEL_SECRET = os.getenv("ALIBABA_MODEL_SECRET", "")
    ALIBABA_MODEL_AGENT_KEY = os.getenv("ALIBABA_MODEL_AGENT_KEY", "")
    ALIBABA_MODEL_ENDPOINT = os.getenv("ALIBABA_MODEL_ENDPOINT", "")
    
    # 应用配置
    API_PREFIX = "/api/v1"
    DEBUG = os.getenv("DEBUG", "False").lower() in ("true", "1", "t")
```

创建`.env`文件:

```
DB_HOST=localhost
DB_PORT=3306
DB_USER=root
DB_PASSWORD=your_password
DB_NAME=pipeline_management

ALIBABA_MODEL_API_KEY=your_alibaba_api_key
ALIBABA_MODEL_SECRET=your_alibaba_secret
ALIBABA_MODEL_AGENT_KEY=your_alibaba_agent_key
ALIBABA_MODEL_ENDPOINT=https://dashscope.aliyuncs.com/api/v1/services/aigc/text-generation/generation
```

### 数据库服务 (db_service.py)

```python
import pymysql
from app.config import Config

class DatabaseService:
    def __init__(self):
        self.connection = None
        self.connect()
    
    def connect(self):
        try:
            self.connection = pymysql.connect(
                host=Config.DB_HOST,
                port=Config.DB_PORT,
                user=Config.DB_USER,
                password=Config.DB_PASSWORD,
                database=Config.DB_NAME,
                charset='utf8mb4',
                cursorclass=pymysql.cursors.DictCursor
            )
        except Exception as e:
            print(f"数据库连接错误: {e}")
            raise
    
    def execute_query(self, sql):
        try:
            if not self.connection or not self.connection.open:
                self.connect()
                
            with self.connection.cursor() as cursor:
                cursor.execute(sql)
                result = cursor.fetchall()
            return result
        except Exception as e:
            print(f"查询执行错误: {e}")
            print(f"SQL: {sql}")
            raise
        
    def get_table_schema(self):
        sql = """
        SELECT COLUMN_NAME, DATA_TYPE, COLUMN_COMMENT
        FROM INFORMATION_SCHEMA.COLUMNS 
        WHERE TABLE_SCHEMA = %s AND TABLE_NAME = 'pipeline_info'
        """
        try:
            with self.connection.cursor() as cursor:
                cursor.execute(sql, (Config.DB_NAME,))
                return cursor.fetchall()
        except Exception as e:
            print(f"获取表结构错误: {e}")
            raise

    def close(self):
        if self.connection and self.connection.open:
            self.connection.close()
```

### LLM服务 (llm_service.py)

```python
import json
import requests
from app.config import Config
from app.services.db_service import DatabaseService
from langchain.chat_models import ChatOpenAI
from langchain.schema import HumanMessage
from langchain.chains import LLMChain
from langchain.prompts import PromptTemplate

class AlibabaBailianLLM:
    def __init__(self):
        self.api_key = Config.ALIBABA_MODEL_API_KEY
        self.secret = Config.ALIBABA_MODEL_SECRET
        self.endpoint = Config.ALIBABA_MODEL_ENDPOINT
        self.agent_key = Config.ALIBABA_MODEL_AGENT_KEY
        self.headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {self.api_key}"
        }
        self.db_service = DatabaseService()
        self.schema_info = self._get_schema_description()
    
    def _get_schema_description(self):
        schema = self.db_service.get_table_schema()
        schema_desc = "数据库表结构 pipeline_info:\n"
        for col in schema:
            schema_desc += f"- {col['COLUMN_NAME']} ({col['DATA_TYPE']}): {col['COLUMN_COMMENT']}\n"
        return schema_desc
    
    def generate_sql_from_question(self, question):
        prompt = f"""
你是一个SQL生成器，根据用户的自然语言问题生成对应的MySQL查询语句。

{self.schema_info}

用户问题: {question}

请生成一个有效的MySQL查询语句，只返回SQL语句本身，不需要其他解释。
        """
        
        try:
            payload = {
                "model": "qwen-max",
                "input": {
                    "messages": [
                        {"role": "system", "content": "你是一个SQL助手，专门将自然语言转换为SQL查询。"},
                        {"role": "user", "content": prompt}
                    ]
                },
                "parameters": {}
            }
            
            response = requests.post(
                self.endpoint,
                headers=self.headers,
                data=json.dumps(payload)
            )
            
            if response.status_code == 200:
                result = response.json()
                sql = result['output']['choices'][0]['message']['content'].strip()
                # 简单清理，移除可能的markdown格式
                if sql.startswith("```sql"):
                    sql = sql.replace("```sql", "").replace("```", "").strip()
                return sql
            else:
                print(f"API请求失败: {response.status_code}, {response.text}")
                return None
        
        except Exception as e:
            print(f"生成SQL错误: {e}")
            return None
    
    def execute_query(self, sql):
        try:
            return self.db_service.execute_query(sql)
        except Exception as e:
            print(f"查询执行错误: {e}")
            return None
```

### SQL生成工具 (sql_generator.py)

```python
from app.services.llm_service import AlibabaBailianLLM

class SQLGenerator:
    def __init__(self):
        self.llm = AlibabaBailianLLM()
    
    def process_query(self, question):
        """处理自然语言查询，生成SQL并执行"""
        try:
            # 生成SQL
            sql = self.llm.generate_sql_from_question(question)
            if not sql:
                return {"status": "error", "message": "无法生成SQL查询"}
            
            # 执行SQL查询
            results = self.llm.execute_query(sql)
            if results is None:
                return {"status": "error", "message": "查询执行失败"}
            
            return {
                "status": "success",
                "data": results,
                "sql": sql,
                "count": len(results)
            }
        
        except Exception as e:
            return {"status": "error", "message": str(e)}
```

### API路由 (routes.py)

```python
from fastapi import APIRouter, HTTPException, Body
from app.utils.sql_generator import SQLGenerator
from pydantic import BaseModel
from typing import Optional, Dict, Any, List

router = APIRouter()
sql_generator = SQLGenerator()

class QueryRequest(BaseModel):
    question: str

@router.post("/query")
async def process_query(request: QueryRequest):
    try:
        result = sql_generator.process_query(request.question)
        if result["status"] == "error":
            raise HTTPException(status_code=400, detail=result["message"])
        return result
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
```

### 主应用入口 (main.py)

```python
import uvicorn
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from app.api.routes import router
from app.config import Config

app = FastAPI(title="Pipeline Management API")

# 配置CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # 生产环境中应该限制为前端域名
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 注册路由
app.include_router(router, prefix=Config.API_PREFIX)

if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=Config.DEBUG)
```

## 前端开发

### 项目结构

```
pipeline-frontend/
├── public/
│   ├── favicon.ico
│   └── index.html
├── src/
│   ├── assets/
│   │   └── logo.png
│   ├── components/
│   │   ├── ChatBox.vue
│   │   ├── DataVisualization.vue
│   │   ├── QueryResult.vue
│   │   └── SqlDisplay.vue
│   ├── views/
│   │   ├── Home.vue
│   │   └── About.vue
│   ├── router/
│   │   └── index.js
│   ├── services/
│   │   └── api.js
│   ├── store/
│   │   └── index.js
│   ├── App.vue
│   └── main.js
├── .env
├── package.json
└── vue.config.js
```

### 项目初始化

```bash
# 安装Vue CLI
npm install -g @vue/cli

# 创建项目
vue create pipeline-frontend

# 进入项目目录
cd pipeline-frontend

# 安装依赖
npm install ant-design-vue axios echarts
```

### 配置文件 (.env)

```
VUE_APP_API_URL=http://localhost:8000/api/v1
```

### API服务 (api.js)

```javascript
import axios from 'axios';

const apiClient = axios.create({
  baseURL: process.env.VUE_APP_API_URL,
  headers: {
    'Content-Type': 'application/json',
  },
  timeout: 10000,
});

export default {
  async sendQuery(question) {
    try {
      const response = await apiClient.post('/query', { question });
      return response.data;
    } catch (error) {
      console.error('API请求错误:', error);
      throw error;
    }
  },
};
```

### 聊天框组件 (ChatBox.vue)

```vue
<template>
  <div class="chat-container">
    <a-card class="chat-box">
      <div class="chat-messages" ref="messagesContainer">
        <template v-for="(message, index) in messages" :key="index">
          <div :class="['message', message.type]">
            <a-avatar :class="message.type">
              {{ message.type === 'user' ? 'U' : 'AI' }}
            </a-avatar>
            <div class="message-content">
              <p>{{ message.content }}</p>
            </div>
          </div>
        </template>
        <div v-if="loading" class="message ai">
          <a-avatar class="ai">AI</a-avatar>
          <div class="message-content">
            <a-spin />
          </div>
        </div>
      </div>
      <div class="chat-input">
        <a-input-search
          v-model:value="inputMessage"
          placeholder="请输入您的问题，例如：查询广东省的燃气管道数量"
          enter-button="发送"
          size="large"
          :disabled="loading"
          @search="sendMessage"
          @keyup.enter="sendMessage"
        />
      </div>
    </a-card>
  </div>
</template>

<script>
import { ref, reactive, watch, nextTick } from 'vue';
import apiService from '../services/api';

export default {
  name: 'ChatBox',
  emits: ['query-result'],
  setup(props, { emit }) {
    const inputMessage = ref('');
    const loading = ref(false);
    const messages = reactive([
      { 
        type: 'ai', 
        content: '您好！我是管道信息助手。您可以询问关于管道信息的问题，例如："查询广东省的燃气管道数量"。' 
      }
    ]);
    const messagesContainer = ref(null);
    
    const scrollToBottom = async () => {
      await nextTick();
      if (messagesContainer.value) {
        messagesContainer.value.scrollTop = messagesContainer.value.scrollHeight;
      }
    };
    
    watch(messages, () => {
      scrollToBottom();
    });
    
    const sendMessage = async () => {
      if (!inputMessage.value.trim() || loading.value) return;
      
      const userMessage = inputMessage.value;
      messages.push({ type: 'user', content: userMessage });
      inputMessage.value = '';
      loading.value = true;
      
      try {
        const result = await apiService.sendQuery(userMessage);
        loading.value = false;
        
        if (result.status === 'success') {
          messages.push({ 
            type: 'ai', 
            content: `已为您查询到${result.count}条结果。` 
          });
          
          // 向父组件发送查询结果
          emit('query-result', {
            data: result.data,
            sql: result.sql,
            count: result.count
          });
        } else {
          messages.push({ 
            type: 'ai', 
            content: `查询失败: ${result.message}` 
          });
        }
      } catch (error) {
        loading.value = false;
        messages.push({ 
          type: 'ai', 
          content: '抱歉，服务出现错误，请稍后再试。' 
        });
        console.error('发送消息失败:', error);
      }
    };
    
    return {
      inputMessage,
      messages,
      loading,
      sendMessage,
      messagesContainer
    };
  }
}
</script>

<style scoped>
.chat-container {
  max-width: 800px;
  margin: 0 auto;
}

.chat-box {
  height: 500px;
  display: flex;
  flex-direction: column;
}

.chat-messages {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.message {
  display: flex;
  align-items: flex-start;
  margin-bottom: 8px;
}

.message.user {
  flex-direction: row-reverse;
}

.message-content {
  max-width: 70%;
  padding: 12px;
  border-radius: 8px;
  margin: 0 12px;
}

.user .message-content {
  background-color: #e6f7ff;
}

.ai .message-content {
  background-color: #f0f2f5;
}

.user.avatar {
  background-color: #1890ff;
  color: white;
}

.ai.avatar {
  background-color: #52c41a;
  color: white;
}

.chat-input {
  padding: 16px;
  border-top: 1px solid #f0f0f0;
}
</style>
```

### 数据可视化组件 (DataVisualization.vue)

```vue
<template>
  <div class="visualization-container">
    <a-tabs v-model:activeKey="activeKey">
      <a-tab-pane key="table" tab="表格视图">
        <a-table
          :dataSource="data"
          :columns="columns"
          :scroll="{ x: 1200 }"
          :pagination="{ pageSize: 10 }"
          size="middle"
        />
      </a-tab-pane>
      <a-tab-pane key="chart" tab="图表视图" v-if="hasChartData">
        <div class="chart-container">
          <div class="chart-options">
            <a-select
              v-model:value="chartType"
              style="width: 120px; margin-right: 16px"
              @change="updateChart"
            >
              <a-select-option value="pie">饼图</a-select-option>
              <a-select-option value="bar">柱状图</a-select-option>
              <a-select-option value="line">折线图</a-select-option>
            </a-select>
            <a-select
              v-model:value="chartDimension"
              style="width: 160px"
              @change="updateChart"
            >
              <a-select-option 
                v-for="col in chartableDimensions" 
                :key="col.dataIndex" 
                :value="col.dataIndex"
              >
                {{ col.title }}
              </a-select-option>
            </a-select>
          </div>
          <div ref="chartContainer" style="width: 100%; height: 400px"></div>
        </div>
      </a-tab-pane>
      <a-tab-pane key="sql" tab="SQL语句">
        <a-card>
          <pre>{{ sql }}</pre>
        </a-card>
      </a-tab-pane>
    </a-tabs>
  </div>
</template>

<script>
import { ref, reactive, computed, onMounted, watch } from 'vue';
import * as echarts from 'echarts';

export default {
  name: 'DataVisualization',
  props: {
    queryResult: {
      type: Object,
      default: () => ({ data: [], sql: '' })
    }
  },
  setup(props) {
    const activeKey = ref('table');
    const chartType = ref('pie');
    const chartDimension = ref('');
    const chartContainer = ref(null);
    let chart = null;
    
    // 处理表格数据
    const data = computed(() => props.queryResult.data || []);
    const sql = computed(() => props.queryResult.sql || '');
    
    // 动态生成表格列
    const columns = computed(() => {
      if (data.value && data.value.length > 0) {
        return Object.keys(data.value[0]).map(key => ({
          title: key,
          dataIndex: key,
          key,
          ellipsis: true,
        }));
      }
      return [];
    });
    
    // 可图表化的维度
    const chartableDimensions = computed(() => {
      if (columns.value.length > 0) {
        return columns.value.filter(col => {
          // 排除数值型数据作为维度
          if (data.value && data.value.length > 0) {
            const sample = data.value[0][col.dataIndex];
            return typeof sample !== 'number' || col.dataIndex.includes('year');
          }
          return true;
        });
      }
      return [];
    });
    
    const hasChartData = computed(() => {
      return data.value && data.value.length > 0;
    });
    
    // 初始化图表
    const initChart = () => {
      if (chartContainer.value) {
        chart = echarts.init(chartContainer.value);
        
        if (chartableDimensions.value.length > 0) {
          chartDimension.value = chartableDimensions.value[0].dataIndex;
          updateChart();
        }
      }
    };
    
    // 更新图表
    const updateChart = () => {
      if (!chart || !data.value || data.value.length === 0) return;
      
      // 根据所选维度对数据进行分组统计
      const groupedData = {};
      data.value.forEach(item => {
        const key = item[chartDimension.value];
        if (key) {
          groupedData[key] = (groupedData[key] || 0) + 1;
        }
      });
      
      // 转换为图表数据格式
      const chartData = Object.entries(groupedData).map(([name, value]) => ({
        name,
        value
      }));
      
      let option;
      
      switch (chartType.value) {
        case 'pie':
          option = {
            title: {
              text: `按${chartDimension.value}统计`,
              left: 'center'
            },
            tooltip: {
              trigger: 'item',
              formatter: '{a} <br/>{b}: {c} ({d}%)'
            },
            legend: {
              orient: 'vertical',
              left: 'left',
              data: Object.keys(groupedData)
            },
            series: [
              {
                name: '数量',
                type: 'pie',
                radius: '50%',
                data: chartData,
                emphasis: {
                  itemStyle: {
                    shadowBlur: 10,
                    shadowOffsetX: 0,
                    shadowColor: 'rgba(0, 0, 0, 0.5)'
                  }
                }
              }
            ]
          };
          break;
        
        case 'bar':
          option = {
            title: {
              text: `按${chartDimension.value}统计`,
              left: 'center'
            },
            tooltip: {
              trigger: 'axis',
              axisPointer: {
                type: 'shadow'
              }
            },
            xAxis: {
              type: 'category',
              data: Object.keys(groupedData),
              axisLabel: {
                rotate: 45,
                interval: 0
              }
            },
            yAxis: {
              type: 'value'
            },
            series: [
              {
                data: Object.values(groupedData),
                type: 'bar'
              }
            ]
          };
          break;
        
        case 'line':
          option = {
            title: {
              text: `按${chartDimension.value}统计`,
              left: 'center'
            },
            tooltip: {
              trigger: 'axis'
            },
            xAxis: {
              type: 'category',
              data: Object.keys(groupedData),
              axisLabel: {
                rotate: 45,
                interval: 0
              }
            },
            yAxis: {
              type: 'value'
            },
            series: [
              {
                data: Object.values(groupedData),
                type: 'line',
                smooth: true
              }
            ]
          };
          break;
      }
      
      chart.setOption(option);
    };
    
    // 监听数据变化
    watch(() => props.queryResult, () => {
      activeKey.value = 'table';
      if (chart) {
        chart.dispose();
        chart = null;
      }
      
      setTimeout(() => {
        initChart();
      }, 100);
    }, { deep: true });
    
    onMounted(() => {
      initChart();
      
      window.addEventListener('resize', () => {
        if (chart) {
          chart.resize();
        }
      });
    });
    
    return {
      activeKey,
      chartType,
      chartDimension,
      chartContainer,
      data,
      sql,
      columns,
      chartableDimensions,
      hasChartData,
      updateChart
    };
  }
}
</script>

<style scoped>
.visualization-container {
  margin-top: 24px;
}

.chart-container {
  padding: 16px;
}

.chart-options {
  margin-bottom: 16px;
  display: flex;
  align-items: center;
}
</style>
```

### 主页面 (Home.vue)

```vue
<template>
  <div class="home">
    <a-layout>
      <a-layout-header class="header">
        <div class="logo">管道信息智能查询系统</div>
      </a-layout-header>
      
      <a-layout-content class="content">
        <a-row :gutter="[16, 16]">
          <a-col :span="24">
            <ChatBox @query-result="handleQueryResult" />
          </a-col>
          
          <a-col :span="24" v-if="hasResults">
            <DataVisualization :queryResult="queryResult" />
          </a-col>
        </a-row>
      </a-layout-content>
      
      <a-layout-footer class="footer">
        管道信息智能查询系统 ©2023
      </a-layout-footer>
    </a-layout>
  </div>
</template>

<script>
import { ref, computed } from 'vue';
import ChatBox from '../components/ChatBox.vue';
import DataVisualization from '../components/DataVisualization.vue';

export default {
  name: 'Home',
  components: {
    ChatBox,
    DataVisualization
  },
  setup() {
    const queryResult = ref({
      data: [],
      sql: '',
      count: 0
    });
    
    const hasResults = computed(() => {
      return queryResult.value && queryResult.value.data && queryResult.value.data.length > 0;
    });
    
    const handleQueryResult = (result) => {
      queryResult.value = result;
    };
    
    return {
      queryResult,
      hasResults,
      handleQueryResult
    };
  }
}
</script>

<style scoped>
.header {
  background: #fff;
  padding: 0 24px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
  position: sticky;
  top: 0;
  z-index: 1;
}

.logo {
  height: 64px;
  line-height: 64px;
  font-size: 20px;
  font-weight: bold;
}

.content {
  padding: 24px;
  min-height: calc(100vh - 64px - 70px);
  background: #f0f2f5;
}

.footer {
  text-align: center;
  padding: 24px 0;
  background: #f0f2f5;
}
</style>
```

### 主入口文件 (main.js)

```javascript
import { createApp } from 'vue'
import App from './App.vue'
import Antd from 'ant-design-vue';
import 'ant-design-vue/dist/antd.css';

const app = createApp(App);
app.use(Antd);
app.mount('#app');
```

### App.vue

```vue
<template>
  <div id="app">
    <Home />
  </div>
</template>

<script>
import Home from './views/Home.vue';

export default {
  name: 'App',
  components: {
    Home
  }
}
</script>

<style>
#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}
</style>
```

## 系统集成

### 启动后端

```bash
cd pipeline_backend
python -m venv venv
source venv/bin/activate  # Windows上使用: venv\Scripts\activate
pip install -r requirements.txt
python main.py
```

### 启动前端

```bash
cd pipeline-frontend
npm install
npm run serve
```

### 系统使用

1. 打开浏览器访问 `http://localhost:8080`
2. 在聊天框中输入自然语言问题，例如：
   - "查询广东省的燃气管道数量"
   - "统计各省市管道类型分布情况"
   - "2010年以后建成的供水管道有哪些？"
   - "地震灾害地区的管道统计"
3. 系统会将自然语言转换为SQL查询，并在图表中展示结果
4. 可以切换表格视图和不同类型的图表视图查看数据

以上就是完整的管道信息系统开发与设计文档，包含了数据库设计、后端开发和前端开发的全部内容。通过这个系统，用户可以使用自然语言查询管道信息，系统会将查询转换为SQL语句并以可视化方式展示结果。